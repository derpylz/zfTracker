"""module analyzes tracks generated by cv_tracking.py"""

import colorsys
import os
from collections import deque

import numpy as np

import cv2


def distance(pts):
    """calculates distance between two points"""
    pt1 = pts[0]
    pt2 = pts[1]
    x_dist = pt1[0] - pt2[0]
    y_dist = pt1[1] - pt2[1]
    return np.sqrt(x_dist ** 2 + y_dist ** 2)


def mean(pts):
    """calculates mean coordinates of track points"""
    avg = []
    for i in zip(*pts):
        avg.append(int(np.mean(i)))
    return tuple(avg)


def median(pts):
    """calculates median coordinates of track points"""
    mdn = []
    for i in zip(*pts):
        mdn.append(int(np.median(i)))
    return tuple(mdn)


def smooth_track(track, method=mean):
    """smooths the track dynamically depending on the distance traveled within the window"""
    wd = deque(maxlen=10)
    smoothed_track = []
    for pt in track:
        if len(wd) == 10:
            d_pts = deque(maxlen=2)
            dist = 0
            for d_pt in wd:
                if len(d_pts) == 2:
                    dist += distance(d_pts)
                d_pts.append(d_pt)
            if dist < 10:
                smoothed_track.append(method(wd))
            else:
                smoothed_track += list(wd)
            wd.clear()
        wd.append(pt.coords)
    if 10 >= len(wd) > 0:
        smoothed_track.append(method(wd))
    return smoothed_track


class Analysis:
    """class contains inner and outer tracks,
    methods for computing the distance and times on tracks
    and to save an image of the tracks"""
    def __init__(self, outer, inner, fps=30, px_size=0.006):
        self.fps = fps
        self.px_size = px_size
        self.outer = outer
        self.inner = inner
        self.tracks = []

    def save_track_image(self, temp_dir, out_dir, iteration):
        """saves tracks to image of mask"""
        image = cv2.imread(os.path.join(temp_dir, 'crop.tiff'))
        for i in range(len(self.tracks)):
            color = colorsys.hsv_to_rgb(i / len(self.tracks), 1.0, 1.0)
            r = int(color[0] * 255)
            g = int(color[1] * 255)
            b = int(color[2] * 255)
            for idx in range(1, len(self.tracks[i])):
                if self.tracks[i][idx - 1] is None or self.tracks[i][idx] is None:
                    continue
                cv2.line(image, self.tracks[i][idx - 1], self.tracks[i][idx], (r, g, b), 1)
        cv2.imwrite(os.path.join(out_dir, str(iteration) + "_tracks.tiff"), image)

    def save_track(self, out_dir, iteration):
        """saves track points to file"""
        all_tracks = {}
        for idx in range(len(self.outer)):
            for point in self.outer[idx]:
                pts_at_frame = all_tracks.get(point.frame, [])
                pts_at_frame.append([point, idx])
                all_tracks[point.frame] = pts_at_frame
        for idx in range(len(self.inner)):
            for point in self.inner[idx]:
                pts_at_frame = all_tracks.get(point.frame, [])
                pts_at_frame.append([point, idx])
                all_tracks[point.frame] = pts_at_frame
        first = True
        with open(os.path.join(out_dir, str(iteration) + "_track_points.txt"), 'w') as out:
            for frame in sorted(all_tracks):
                if first:
                    out.write("frame\tx\ty\ttrack\n")
                    first = False
                for pt in all_tracks[frame]:
                    out.write(str(frame) + '\t')
                    out.write(str(pt[0].coords[0]) + '\t')
                    out.write(str(pt[0].coords[1]) + '\t')
                    out.write(str(pt[1]) + '\n')

    def analyze(self, outfile, iteration, vel=False):
        """writes information about track to file"""
        distance_outer = 0
        distance_inner = 0
        frames_outer = 0
        frames_inner = 0
        # iterate through points on tracks and calculate time
        # do this for inner and for outer track
        for track in self.outer:
            prev_pt = False
            frames_on_track = 0
            for pt in track:
                if not prev_pt:
                    prev_pt = pt
                    frames_on_track += 1
                    continue
                intermediate_frames = pt.frame - prev_pt.frame
                frames_on_track += intermediate_frames
                prev_pt = pt
            frames_outer += frames_on_track
            sm_track = smooth_track(track)
            self.tracks.append(sm_track)
            pts = deque(maxlen=2)
            for pt in sm_track:
                if len(pts) == 2:
                    distance_outer += distance(pts)
                pts.append(pt)

        for track in self.inner:
            prev_pt = False
            frames_on_track = 0
            for pt in track:
                if not prev_pt:
                    prev_pt = pt
                    frames_on_track += 1
                    continue
                intermediate_frames = pt.frame - prev_pt.frame
                frames_on_track += intermediate_frames
                prev_pt = pt
            frames_inner += frames_on_track
            sm_track = smooth_track(track)
            self.tracks.append(sm_track)
            pts = deque(maxlen=2)
            for pt in sm_track:
                if len(pts) == 2:
                    distance_inner += distance(pts)
                pts.append(pt)

        distance_outer *= self.px_size
        distance_inner *= self.px_size
        time_outer = frames_outer/self.fps
        time_inner = frames_inner/self.fps

        if vel:
            try:
                velocity = (distance_inner + distance_outer) / (time_inner + time_outer)
            except ZeroDivisionError:
                velocity = "NaN"
            # write tab-separated file with values
            with open(outfile, 'a') as out:
                out.write(str(iteration) + '\t')
                out.write(str(time_outer) + '\t')
                out.write(str(distance_outer) + '\t')
                out.write(str(time_inner) + '\t')
                out.write(str(distance_inner) + '\t')
                out.write(str(velocity) + '\n')
        else:
            try:
                outer_time_percentage = (time_outer / (time_outer + time_inner)) * 100
                outer_distance_percentage = (distance_outer / (distance_outer + distance_inner)) * 100
            except ZeroDivisionError:
                outer_time_percentage = 'NaN'
                outer_distance_percentage = 'NaN'

            # write tab-separated file with values
            with open(outfile, 'a') as out:
                out.write(str(iteration) + '\t')
                out.write(str(time_outer) + '\t')
                out.write(str(distance_outer) + '\t')
                out.write(str(time_inner) + '\t')
                out.write(str(distance_inner) + '\t')
                out.write(str(outer_time_percentage) + '\t')
                out.write(str(outer_distance_percentage) + '\n')
